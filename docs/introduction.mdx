---
title: Introduction
description: "Node.js/TypeScript HTTP client with browser TLS fingerprint impersonation (JA3/JA4). Bypass Cloudflare, DataDome, and other anti-bot TLS fingerprinting. Rust-powered."
---

# wreq-js

Node.js/TypeScript HTTP client that bypasses Cloudflare, DataDome, Akamai, and other anti-bot TLS fingerprinting by impersonating real browser network behavior.

<CardGroup cols={2}>
  <Card title="Native Performance" icon="bolt">
    No process spawning or browser overhead. Native speed via Rust bindings.
  </Card>
  <Card title="Real Browser Fingerprints" icon="fingerprint">
    Authentic TLS (JA3/JA4) and HTTP/2 fingerprints from Chrome, Firefox, Safari, and more.
  </Card>
  <Card title="Drop-in Fetch API" icon="code">
    A fetch-like API with extra options for browser profiles and sessions.
  </Card>
  <Card title="WebSocket Support" icon="plug">
    Full WebSocket support with consistent browser fingerprinting.
  </Card>
</CardGroup>

## Why wreq-js?

Standard HTTP clients like `axios`, `fetch`, `got`, and `curl` don't behave like browsers on the network layer. They differ in:

- **TLS handshake**: cipher suite order and extension sets
- **HTTP/2 frames**: SETTINGS and PRIORITY behavior
- **Header ordering**: the order headers are sent on the wire

Anti-bot systems like Cloudflare, DataDome, and Akamai use these signals to flag and block non-browser clients.

`wreq-js` reproduces browser networking behavior using the [`wreq`](https://github.com/0x676e67/wreq) Rust engine underneath. Your job is to write scripts. wreq-js handles the network-level impersonation.

## When to use wreq-js

<AccordionGroup>
  <Accordion title="✅ Great for" icon="check">
    - Bypassing Cloudflare, DataDome, Akamai TLS fingerprinting
    - Web scraping and data collection
    - API automation with stealth requirements
    - High-throughput HTTP requests
    - Login flows and session management
    - Proxy rotation scenarios
  </Accordion>
  <Accordion title="❌ Not for" icon="xmark">
    - DOM or JavaScript execution (not a browser runtime)
    - CAPTCHA solving or page automation
    - Full browser automation (use Playwright/Puppeteer instead)
  </Accordion>
</AccordionGroup>

## Quick Example

<Note>
If your script makes more than one request, start with a **session** and reuse it.
Sessions reuse cookies and connection state, and are usually much faster than repeated one-off `fetch()` calls.
</Note>

```typescript
import { fetch } from 'wreq-js';

const response = await fetch('https://example.com/api', {
  browser: 'chrome_142',
  os: 'windows',
});

console.log(await response.json());
```

That is it. You get browser impersonation with a familiar, fetch-like API.

## Next Steps

<CardGroup cols={2}>
  <Card title="Quickstart" icon="rocket" href="/quickstart">
    Get up and running in under 5 minutes.
  </Card>
  <Card title="Installation" icon="download" href="/installation">
    Detailed installation instructions for all platforms.
  </Card>
</CardGroup>
