---
title: Transport
description: "Learn how Transport controls reusable network settings such as proxy and emulation options."
---

## What is a transport?

A **transport** is a reusable network layer handle that owns:

1. Transport level settings like `proxy`, `browser`, `os`, and `insecure`
2. Reusable network context used by requests and sessions

Think of it as a "shared network context" you can attach to requests.

## When should I use Transport vs Sessions?

Use the simplest tool that matches your needs:

| You needâ€¦ | Use | Why |
| --- | --- | --- |
| One-off request with maximum isolation | Ephemeral `fetch()` | Separate request context per call |
| Multi-step flow with cookies (login, checkout, etc.) | Sessions | Shared session context across requests |
| Reuse a single proxy across many requests | Transport | You create it once and reuse it |
| Separate cookie jars with shared transport config | Sessions + shared Transport | Sessions stay isolated while sharing transport settings |

## Creating and reusing a transport

A common pattern is **one transport per proxy**, reused across many requests:

```typescript
import { createTransport, fetch } from 'wreq-js';

const transport = await createTransport({
  proxy: 'http://user:pass@proxy.example.com:8080',
  browser: 'chrome_142',
});

try {
  const r1 = await fetch('https://example.com', { transport });
  const r2 = await fetch('https://example.com/pricing', { transport });

  console.log(r1.status, r2.status);
} finally {
  await transport.close();
}
```

## Using Transport with sessions

Sessions are the right default for cookie-based flows. If you want **multiple sessions** (separate cookies) to share a **single transport context** (same proxy/emulation), pass the same transport per request:

```typescript
import { createSession, createTransport } from 'wreq-js';

const transport = await createTransport({
  proxy: 'http://proxy.example.com:8080',
  browser: 'chrome_142',
});

const sessionA = await createSession();
const sessionB = await createSession();

try {
  await sessionA.fetch('https://example.com', { transport });
  await sessionB.fetch('https://example.com', { transport });
} finally {
  await Promise.all([sessionA.close(), sessionB.close(), transport.close()]);
}
```

## Ownership rules (important)

When you pass a `transport`, it owns `browser`, `os`, `proxy`, and `insecure`.

- Do **not** also set `browser`, `os`, `proxy`, or `insecure` on the request.
- Prefer creating a separate transport if you need different settings.

## Lifecycle

Always close transports you create:

1. Close when you no longer need the transport: `await transport.close()`
2. After closing, the transport cannot be used again

## Related

1. API details: `/api-reference/transport`
2. Cookie flows: `/concepts/sessions`
